/**
 * CuraEngine WASM Worker
 *
 * Handles slicing operations in a dedicated Web Worker.
 * This isolates the WASM module from the main thread and prevents UI blocking.
 */

/// <reference lib="webworker" />

import type { CuraSettings, SlicerResult } from './cura-types';

// WASM module interface (generated by Emscripten)
interface CuraEngineModule {
  callMain(args: string[]): number;
  FS: {
    writeFile(path: string, data: string | Uint8Array, options?: { encoding?: string }): void;
    readFile(path: string, options?: { encoding?: string }): string | Uint8Array;
    unlink(path: string): void;
    mkdir(path: string): void;
  };
}

declare const CuraEngine: (config?: any) => Promise<CuraEngineModule>;

class CuraSlicerWorker {
  private module: CuraEngineModule | null = null;
  private initialized = false;

  /**
   * Initialize the CuraEngine WASM module
   */
  async init(): Promise<void> {
    if (this.initialized) {
      console.log('[CuraWorker] Already initialized');
      return;
    }

    console.log('[CuraWorker] Loading CuraEngine WASM...');

    try {
      // Load WASM module (will be bundled by Vite)
      this.module = await CuraEngine({
        locateFile: (path: string) => {
          // Point to WASM file in public directory
          if (path.endsWith('.wasm')) {
            return '/wasm/cura-engine.wasm';
          }
          return path;
        }
      });

      this.initialized = true;
      console.log('[CuraWorker] CuraEngine WASM loaded successfully');
    } catch (error) {
      console.error('[CuraWorker] Failed to load WASM:', error);
      throw new Error(`CuraEngine WASM initialization failed: ${error}`);
    }
  }

  /**
   * Slice an STL file to G-code
   *
   * @param stlData - STL file as Uint8Array
   * @param settings - Cura slicer settings
   * @returns G-code string and metadata
   */
  async slice(stlData: Uint8Array, settings: CuraSettings): Promise<SlicerResult> {
    if (!this.module) {
      throw new Error('CuraEngine WASM not initialized. Call init() first.');
    }

    console.log(`[CuraWorker] Slicing STL (${stlData.byteLength} bytes)...`);
    const startTime = performance.now();

    try {
      // 1. Write STL to virtual filesystem
      this.module.FS.writeFile('/input/model.stl', stlData);
      console.log('[CuraWorker] STL written to virtual FS');

      // 2. Write settings as JSON
      const settingsJson = this.convertSettingsToJson(settings);
      this.module.FS.writeFile('/input/settings.json', settingsJson);
      console.log('[CuraWorker] Settings written to virtual FS');

      // 3. Run CuraEngine
      console.log('[CuraWorker] Starting CuraEngine...');
      const args = [
        'slice',
        '-j', '/input/settings.json',    // Settings JSON
        '-o', '/output/output.gcode',    // Output G-code
        '-l', '/input/model.stl'         // Input STL
      ];

      const exitCode = this.module.callMain(args);

      if (exitCode !== 0) {
        throw new Error(`CuraEngine exited with code ${exitCode}`);
      }

      console.log('[CuraWorker] CuraEngine completed successfully');

      // 4. Read output G-code
      const gcode = this.module.FS.readFile('/output/output.gcode', {
        encoding: 'utf8'
      }) as string;

      if (!gcode || gcode.length === 0) {
        throw new Error('CuraEngine produced empty G-code');
      }

      console.log(`[CuraWorker] G-code generated (${gcode.length} bytes)`);

      // 5. Parse metadata from G-code comments
      const metadata = this.parseGcodeMetadata(gcode);

      // 6. Cleanup virtual filesystem
      this.cleanup();

      const elapsedTime = performance.now() - startTime;
      console.log(`[CuraWorker] Slicing completed in ${elapsedTime.toFixed(0)}ms`);

      return {
        gcode,
        metadata: {
          ...metadata,
          slicingTime: elapsedTime,
          stlSize: stlData.byteLength,
          gcodeSize: gcode.length
        }
      };

    } catch (error) {
      console.error('[CuraWorker] Slicing failed:', error);
      this.cleanup(); // Cleanup even on error
      throw error;
    }
  }

  /**
   * Convert BrepFlow settings to Cura JSON format
   */
  private convertSettingsToJson(settings: CuraSettings): string {
    // CuraEngine expects specific setting names
    // Full list: https://github.com/Ultimaker/CuraEngine/blob/master/include/settings/Settings.h

    const curaSettings = {
      // Print settings
      layer_height: settings.layerHeight || 0.2,
      layer_height_0: settings.firstLayerHeight || settings.layerHeight || 0.2,

      // Wall settings
      wall_thickness: settings.wallThickness || 1.2,
      wall_line_count: settings.wallLineCount || 3,

      // Infill settings
      infill_sparse_density: settings.infillDensity || 20,
      infill_pattern: settings.infillPattern || 'grid',

      // Speed settings
      speed_print: settings.printSpeed || 60,
      speed_travel: settings.travelSpeed || 150,
      speed_infill: settings.infillSpeed || settings.printSpeed || 60,
      speed_wall: settings.wallSpeed || settings.printSpeed || 60,

      // Temperature settings
      material_print_temperature: settings.nozzleTemp || 210,
      material_bed_temperature: settings.bedTemp || 60,

      // Support settings
      support_enable: settings.supportEnabled || false,
      support_type: settings.supportType || 'everywhere',
      support_pattern: settings.supportPattern || 'grid',
      support_infill_rate: settings.supportDensity || 20,

      // Retraction settings
      retraction_enable: settings.retractionEnabled !== false,
      retraction_amount: settings.retractionDistance || 5,
      retraction_speed: settings.retractionSpeed || 45,

      // Machine settings
      machine_nozzle_size: settings.nozzleSize || 0.4,
      machine_width: settings.bedWidth || 220,
      machine_depth: settings.bedDepth || 220,
      machine_height: settings.bedHeight || 250,
      machine_heated_bed: settings.heatedBed !== false,

      // Adhesion settings
      adhesion_type: settings.adhesionType || 'skirt',

      // Quality settings
      magic_spiralize: settings.spiralize || false,

      // Output settings
      machine_gcode_flavor: settings.gcodeFlavor || 'RepRap (Marlin/Sprinter)'
    };

    return JSON.stringify(curaSettings, null, 2);
  }

  /**
   * Parse metadata from G-code comments
   */
  private parseGcodeMetadata(gcode: string): {
    printTime?: number;
    filamentUsed?: number;
    layerCount?: number;
  } {
    const metadata: any = {};

    // Parse Cura-generated comments
    const lines = gcode.split('\n');

    for (const line of lines) {
      // TIME: Print time in seconds
      if (line.includes(';TIME:')) {
        metadata.printTime = parseInt(line.split(':')[1]);
      }

      // Filament used in mm
      if (line.includes(';Filament used:')) {
        const match = line.match(/:([\d.]+)m/);
        if (match) {
          metadata.filamentUsed = parseFloat(match[1]) * 1000; // Convert m to mm
        }
      }

      // Layer count
      if (line.includes(';LAYER_COUNT:')) {
        metadata.layerCount = parseInt(line.split(':')[1]);
      }
    }

    return metadata;
  }

  /**
   * Cleanup virtual filesystem
   */
  private cleanup(): void {
    if (!this.module) return;

    try {
      this.module.FS.unlink('/input/model.stl');
      this.module.FS.unlink('/input/settings.json');
      this.module.FS.unlink('/output/output.gcode');
      console.log('[CuraWorker] Virtual filesystem cleaned up');
    } catch (error) {
      console.warn('[CuraWorker] Cleanup warning:', error);
      // Non-fatal, continue
    }
  }

  /**
   * Get CuraEngine version
   */
  async getVersion(): Promise<string> {
    if (!this.module) {
      throw new Error('CuraEngine not initialized');
    }

    try {
      const result = this.module.callMain(['--version']);
      return 'CuraEngine 5.7.2 (WASM)';
    } catch (error) {
      return 'Unknown';
    }
  }
}

// Worker singleton
let worker: CuraSlicerWorker | null = null;

// Worker message handler
self.onmessage = async (event: MessageEvent) => {
  const { type, payload, id } = event.data;

  try {
    // Initialize worker on first message
    if (!worker) {
      worker = new CuraSlicerWorker();
      await worker.init();
    }

    switch (type) {
      case 'CURA_SLICE': {
        const result = await worker.slice(
          payload.stl,
          payload.settings
        );
        self.postMessage({ id, type: 'CURA_SLICE_RESULT', payload: result });
        break;
      }

      case 'GET_SLICER_VERSION': {
        const version = await worker.getVersion();
        self.postMessage({ id, type: 'VERSION_RESULT', payload: version });
        break;
      }

      default:
        throw new Error(`Unknown message type: ${type}`);
    }

  } catch (error: any) {
    console.error('[CuraWorker] Error:', error);
    self.postMessage({
      id,
      type: 'ERROR',
      payload: {
        message: error.message,
        stack: error.stack
      }
    });
  }
};

// Worker ready
console.log('[CuraWorker] Worker thread started');
